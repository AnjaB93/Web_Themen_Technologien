<html>
  <!DOCTYPE html>
  <head>
    <meta charset="utf-8" />
    <title>Frameworks</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/Web_Themen_Technologien/style.css" />
  </head>
  <body>
    <header class="header-unterseiten">
      <h1>Frameworks</h1>
      <h2>Was ist ein Framework? & Wann wird es eingesetzt?</h2>
    </header>
    <div class="container-unterseiten">
      <div class="container-box-unterseiten">
        <p>
          Wie schon bei den Libraries erwähnt, wirken Framewors im ersten Moment
          ähnlich zu einer Library. Frameworks sind aber sozusagen eine
          Struktur/Grundgerüst mit vorgefertigten verschiedenen Materialien, mit
          dem du dir dein Projekt selbst einfach und schnell aufbauen kannst.
          Zusätzlich gibt es noch einen weiteren entscheidenden Unterschied, und
          zwar die sogenannte "inversion of control" (Steuerungsumkehr).
        </p>
        <p>
          Wird eine Library verwendet ist man selbst für den Ablauf der
          Anwendung verantwortlich. Das heißt man legt selbst fest, wann und wo
          die Library aufgerufen werden soll.
        </p>
        <p>
          Bei einem Framework ist dies selbst für den Ablauf verantwortlich. Es
          gibt zwar Platz um eigenen Code einzubringen, entscheidet aber selbst
          wann dieser aufgerufen wird.
        </p>

        <h3>
          Hier ist ein Beispiel mit jQuery (einer Bibliothek) und Vue.js (einem
          Framework):
        </h3>
        <p>
          Stell dir vor, wir möchten eine Fehlermeldung anzeigen, wenn ein
          Fehler vorliegt. In unserem Beispiel klicken wir auf eine Schaltfläche
          und tun so, als ob ein Fehler auftritt.
        </p>
        <p>Mit jQuery:</p>
        <img
          src="/Web_Themen_Technologien/assets/jQuery.png"
          alt="Code_jQuery"
        />
        <p>
          Hier verwenden wir jQuery. Wir sagen dem Programm genau wo wir es
          brauchen. Das heißt nicht, dass für jQuery-Funktionen bestimmte
          Eingaben nicht erforderlich sind, wenn wir sie aufrufen, aber jQuery
          selbst ist eine Bibliothek dieser Funktionen. Wir sind verantwortlich.
        </p>
        <p>Mit Vue.js:</p>
        <img
          src="/Web_Themen_Technologien/assets/VueJS.png"
          alt="Code_Vue.js"
        />
        <a
          id="quelle"
          target="_blank"
          href="https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/"
          >freecodecamp.org</a
        >
        <p>
          Bei Vue.js müssen wir sozusagen die Lücken füllen. Der Vue-Konstruktor
          ist ein Objekt mit bestimmten Eigenschaften. Es sagt uns was es
          braucht und Vue.js entscheidet dann wann es es braucht. Vue kehrt die
          Steuerung des Programms um. Wir stecken unseren Code rein und Vue
          übernimmt die Verantwortung.
        </p>
        <h3>Frameworks für individuelle Problemstellungen</h3>
        <p>
          Frameworks bieten einen Basis-Bausteinkasten und nehmen somit Einfluss
          auf die Design-Struktur unseres Programms. Es gibt für viele
          Einsatzmöglichkeiten passende Framework-Typen:
        </p>
        <dl>
          <dt>Web-Frameworks:</dt>
          <dd>
            mit Zuschnitt auf die Entwicklung und Programmierung dynamischer Web
            Sites und Web Applikationen
          </dd>
          <dt>Application Frameworks:</dt>
          <dd>
            als Programmier-Gerüst für Anwendungen mit spezifischen Strukturen
            und Funktionen
          </dd>
          <dt>Komponenten-Frameworks:</dt>
          <dd>
            mit speziellem Umgebungsrahmen für die Programmierung und finale
            Einbindung von Programm-Paketen
          </dd>
          <dt>Coordination Frameworks:</dt>
          <dd>
            mit der Möglichkeit der Einrichtung von Geräte-Interaktionen, das
            heißt einer Abfolge zu steuernder Ablaufschritte
          </dd>
          <dt>Domain Frameworks:</dt>
          <dd>als Programmier-Rahmen für definierte Problembereiche</dd>
          <dt>Class Frameworks:</dt>
          <dd>
            mit der Aufgabenstellung einer Zusammenfassung von „Klassen“ und
            „Methoden“, im Sinne einer optimalen Unterstützung des
            Programmierers bei der Implementierung spezifischer Anwendungen
          </dd>
          <dt>Test Frameworks:</dt>
          <dd>
            zum Testen entwickelter Software Programme. Als klassische Beispiele
            sind „Selenium oder Cypress“ für den Test von Web Applikationen und
            „JUnit“ für den Test von Modulen zu nennen
          </dd>
          <dt>Wofür werden Js-Frameworks verwendet?</dt>
          <dd>
            <ul>
              <li>Webseiten erstellen</li>
              <li>Front-End App Entwicklung</li>
              <li>Back-End App-Entwicklung</li>
              <li>Hybride App-Entwicklung</li>
              <li>Ecommerce Anwendungen</li>
              <li>Modulare Skripte bauen, zum Beispiel Node.js</li>
              <li>DOM manuell aktualisieren</li>
              <li>
                Automatisieren von sich wiederholenden Aufgaben mit Templates
                und 2-Wege-Bindung
              </li>
              <li>Videospiele entwickeln</li>
              <li>Bildkarussells erstellen</li>
              <li>Codes testen und debuggen</li>
              <li>Module bündeln</li>
            </ul>
          </dd>
        </dl>

        <p>
          Auf dieser Seite findest du viele verschiedene
          <a
            target="_blank"
            href="https://kinsta.com/de/blog/javascript-bibliotheken/#was-sind-javascript-bibliotheken"
            >Frameworks.
          </a>
        </p>
        <h3>Angular:</h3>
        <p>
          Angular ist ein Anwendungsdesign-Framework und eine
          Entwicklungsplattform zum Erstellen effizienter und anspruchsvoller
          Single-Page-Apps. Zudem wird es nicht mit JavaScript, sondern
          Typescript aufgebaut.
        </p>
        <dl>
          <dt>Was kann Angular?</dt>
          <dd>
            <ul>
              <li>
                Es ist ein komponentenbasiertes Framework zum Erstellen
                skalierbarer Webanwendungen
              </li>
              <li>
                Es ist eine sammlung gut intergierter Bibliotheken, die viele
                Funktionen abdecken. Wie bspw. Routing, Formularverwaltung,
                Client-Server-Kommunikation usw.
              </li>
              <li>
                Es hat eine Reihe von Entwicklertools, mit denen der Code
                einfacher entwickelt, erstellt, getestet und aktualisiert werden
                kann
              </li>
            </ul>
          </dd>
          <dd>
            Hier sind Beispiele und Insights aus dem
            <a href="https://angular.io/tutorial"
              >Tour of Heroes Tutorial von Angular</a
            >:
            <p class="exkurs">Kapitel 1</p>
            Im ersten Kapitel geht es um die Grundstruktur des Helden-Editors:

            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-bv6kwg?embed=1&file=src/app/heroes/heroes.component.html&hideNavigation=1"
              ></iframe>
            </div>
            <ul>
              <li>
                Mit der CLI (Command Line Interface) wurde als erstes die
                HeroesComponent angelegt.
              </li>
              <li>
                In der app.component.html wurde die HeroesComponent eingetragen
                um diese anzeigen zu lassen. Die AppComponent ist sozusagen die
                Anzeige für alle Componenten. Wenn hier eine Component
                eingetragen wird kann über den CLI Befehl "ng serve" diese auf
                dem lokalen Server angezeigt werden.
              </li>
              <li>
                Durch die UpperCasePipe im &lt;h2&gt; in der
                heroes.component.html werden die Heronamen immer in
                Großbuchstaben geschrieben.
              </li>
              <li>
                Durch ngModel wurde eine Verbidnung von hero.name mit der
                Textbox hergestellt. ([(ngModel)] ist die bidirektionale
                Datenbindungssyntax von Angular.) Das heißt hier fließen die
                Daten in beide Richtungen, sodass die hero.name Eigenschaft an
                die Textbox und wieder zurück gegeben werden kann.
              </li>
              <li>
                Durch den Import von "FormsModule" im AppModule kann die ngModel
                Direktive aufgerufen werden. Das heißt hierdurch wird das
                App-Modul erstellt und dies enthält dann alle Abhängigkeiten und
                Komponenten. Durch laden des Moduls wird der AppComponent
                gestartet.
              </li>
            </ul>
            <p class="exkurs">Kapitel 2</p>
            Im zweiten Kapitel geht es um die Liste der Heroes die ausgewählt
            werden können:
            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-ivy-cfvmx8?file=src%2Fapp%2Fheroes%2Fheroes.component.html"
              ></iframe>
            </div>

            <ul>
              <li>
                Durch eine Mock-Datei "mock-heroes.ts" wurde eine Liste an
                Heroes generiert.
              </li>
              <li>
                Damit die Nutzer:innen einen Hero auswählen kann wird diese
                Liste angezeigt. Hierfür wurde "*ngFor" verwendet. Dies ist eine
                "Repeater-Direktive" von Angular ähnlich wie eine For-Schleife
                wiederholt er in hier das Host-Element für jedes Element in der
                Liste. &lt;li&gt; ist das Host-Element. Die Klasse heroes
                enthält die Liste der "Helden" aus der HeroesComponent Klasse.
                Das aktuelle Heldenobjekt ist in "hero" enthalten und wird durch
                das *ngFor für jede Iteration in der Liste angezeigt.
              </li>
              <li>
                (click)="onSelect(hero)" ist ein Besipiel für die event binding
                Syntax von Agular. Hier wird ein Klick-Event auf einen Hero
                vorgenommen. Das Event wird in der heroes.component.ts als
                Methode definiert (event handler). Zunächst soll kein Hero
                ausgewählt sein, bis der/die Nutzer:in auf einen Hero klickt.
              </li>
              <li>
                Mit "*ngIf" in der heroes.component.html wird nun definiert,
                wann ein Hero ausgewählt (selectedHero) ist und wann nicht.
                Ebenfalls wie bei *ngFor ist *ngIf ähnlich der If-Bedingung.
                Sprich wenn kein Hero ausgewählt ist zeige keine Details an, ist
                ein Hero ausgewählt zeige die Details des Hero's.
              </li>
              <li>
                Als letztes wurden Klassenanbindungen (class binding) zu den
                jeweiligen Elementen die eine andere Klasse haben sollen wenn
                sie bspw. ausgewählt sind, hinzugefügt. Im heroes.componen.css
                wurden hierfür Styles für die verschiedenen States der Hero's
                angelegt.
              </li>
            </ul>
            <p class="exkurs">Kapitel 3</p>
            Im dritten Kapitel geht es darum verschiedene Teile einer Componente
            auszulagern um für jede Funktion/Darstellung einzelne
            Feature-Componenten zu haben:
            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-ivy-cfvmx8?embed=1&file=src/app/heroes/heroes.component.html"
              ></iframe>
            </div>

            <ul>
              <li>
                Es wurde eine neue Componente erstellt mit dem Namen
                "hero-detail.component". Diese dient der Anzeige der
                Herodetails, hier wurde also lediglich der Detailpart aus der
                hero.component in eine extra Komponente ausgelagert.
              </li>
              <li>
                [hero]="selectedHero" ist ein Angular "property binding", das
                heißt es wurde der HeroesComponent die Kontolle über die
                untergeordnete Hero-DetailComponent gegeben. Es sollte somit
                also jedesmal wenn auf einen Hero geklickt wird das property
                binding aktualisiert und die Details zu dem Hero angezeigt
                werden.
              </li>
              <li>
                Damit die Hero-DetailComponent weiß welcher Hero gemeint ist
                wird "@Input() hero?: Hero;" in die hero-detail.component.ts
                hinzugefügt. Somit werden Daten zwischen den Eltern- und
                Kind-Komponenten geteilt. --> Über @Output kann die
                Kind-Komponente Daten an die Eltern-Komponente schicken.
              </li>
            </ul>
            <p class="exkurs">Kapitel 4</p>
            Im vierten Kapitel geht es darum verschiedene Services bereit zu
            stellen. Diese Services können alle Anwendungsklassen benutzen um
            Helden zu erhalten. Anstatt diesen Dienst über das Stichwort "new"
            zu erstellen, wird dies über die Angular "dependency injection" im
            Konstruktor der HeroesComponent eingefügt:
            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-ivy-67p3hy?embed=1&file=src/app/heroes/heroes.component.ts"
              ></iframe>
            </div>
            <ul>
              <li>
                Zunächst wird ein Angular Service erstellt mit dem Namen
                "hero.service.ts". Durch hinzufügen der heroService Parameter im
                Konstruktor der HeroesComponent mit "constructor(private
                heroService: HeroService) {}" werden diese injiziert. Wenn
                Agular jetzt eine HeroesComponent erstellt, setzt das Dependency
                Injection system die heroService Parameter als Instanz des
                HeroServices.
                <p class="exkurs">@Injectable</p>
                Injectables markieren die Klasse als "Teilnehmer" des Dependency
                Injection systems. Das heißt der Injektor erstellt Dependencies
                (Abhängigkeiten) und verwaltet einen Container mit dependency
                instances die er nach Möglichkeit wiederverwenden kann. Ein
                provider ist ein Objekt, das einem Injektor mitteilt, wie eine
                dependency abgerufen oder erstellt wird. Damit in Angular die
                Dienste aufgerufen werden können müssen diese im Konstruktor der
                Komponente aufgerufen werden.
                <img
                  src="/Web_Themen_Technologien/assets/injector-injects.png"
                  alt="Injectable and Dependency Injection"
                />
              </li>
              <li>
                Der Konstuktor sollte so wenig wie möglich machen, deshalb wird
                mit getHeroes() im ngOnInit Lifecycle-Hook aufgerufen. Angular
                soll dann, nach dem er eine Instanz für die HeroesComponent
                konstruiert hat, ngOnInit() aufrufen. <br />
                <pre><code>  
    ngOnInit() { 
      this.getHeroes(); 
    }
    </code
                  ></pre>
              </li>
              <li>
                Da wir gerade eine Mock-Datei mit "Scheinhelden" haben lassen
                sich diese synchron abrufen. Dies soll jedoch in Zukunft
                asynchron ablaufen, wenn bspw. die Daten über eine Remote-Server
                abgerufen werden. Somit benötigen wir einen asynchrone Signatur
                umd diese in Zukunft asynchron abgrufen zu können. Die
                getHeroes() Methode wird deshalb zu einer Beobachtbaren Methode
                gemacht:
                <pre><code>
    import { Observable, of } from 'rxjs';

    getHeroes(): Observable&lt;Hero[]&gt; {
      const heroes = of(HEROES);
      return heroes;
    }
                </code></pre>
                of(HEROES) gibt nun ein Observable&lt;Hero[]&gt; zurück, der
                einen einzelnen Wert ausgibt, nämlich das Array von
                Scheinhelden. Die HeroService.getHeroes Methode hat bisher
                Hero[] zurückgegeben. Nun gibt sie Observable&lt;Hero[]&gt;
                zurück. Das muss so auch noch in der HeroesComponent angepasst
                werden. Deshalb wird die getHeroes() mit einem subscribe
                ergänzt:
                <pre><code>
    getHeroes(): void {
      this.heroService.getHeroes()
          .subscribe(heroes => this.heroes = heroes);
    }
                </code></pre>
                Mit dieser Version der getHeroes() Methode wird auf das
                Observable gewartet, welches den Array jetzt oder in einigen
                Minuten ausgibt. Mit der subscribe() Methode wird nun das
                ausgegebene Array an den Callback übergeben der die heroes
                Eigenschaft der Komponente festlegt.
                <p class="exkurs">Observables</p>
                Observables (dt. beobachtbar)<br />
                Ein Observer - zu Deutsch Beobachter - behält etwas im Auge und
                reagiert auf mögliche Änderungen. Möchte ein anderer
                Anwendungsteil vom Observer über die Änderungen am Observable
                informiert werden, kann er sich an diesem dazu an- (subscribe)
                und auch wieder abmelden (unsubscribe). Ein Observable kann
                dabei abstrakt einfach als Daten-Stream betrachtet werden.
                Dadurch sind diese auch flexibel einsetzbar und es können
                beispielsweise mehrere Observables verknüpft oder
                zusammengefasst werden. Das Prinzip ähnelt stark dem
                Observer-Pattern und nennt sich Reactive Programming. Angular
                nutzt als Basis dazu die Observables der ReactiveX Architektur
                (kurz: RxJS).
                <p class="exkurs">RxJS</p>
                RxJS ist eine Bibliothek für die reaktive Programmierung mit
                Observables, um die Erstellung von asynchronem oder
                callback-basiertem Code zu vereinfachen.
              </li>
              <br />
              <li>
                Services sind eine Möglichkeit, Informationen zwischen Klassen
                auszutauschen, die sich nicht kennen. Zusätzlich wurde noch der
                "message.service.ts" erstellt. Der MessageService injiziert an
                zwei Stellen. Inject in HeroService, der den Dienst zum Senden
                einer Nachricht verwendet. Inject in MessagesComponent, die
                diese Nachricht anzeigt und auch die ID anzeigt, wenn der
                Benutzer auf einen Helden klickt.
              </li>
              <li>
                Damit die Message angezeigt werden kann wurde eine
                MessageComponent erstellt. Diese gibt aus welcher Hero
                angeklickt wurde und welche ID er hat. Diese können über den
                "clear messages" Button gelöscht werden.
              </li>
            </ul>
            <p class="exkurs">Kapitel 5</p>
            Im fünften Kapitel geht es darum zwischen zwei Ansichten über das
            Angular Routing-Module zu wechseln. Es geht also um eine erweiterte
            Navigation innerhalb der Seite und die verschiedenen Abhängigkeiten
            dieser zueinander:
            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-ivy-quvz9h?embed=1&file=src/app/hero.service.ts"
              ></iframe>
            </div>
            <ul>
              <li>
                Der/Die Nutzer:in kann dann wie folgt in der Anwendung
                navigieren:
                <img
                  src="/Web_Themen_Technologien/assets/nav-diagram.png"
                  alt="Navigationsschaubild Tour of Heroes"
                />
              </li>
              <li>
                Wie auf der Grafik zu sehen wurde eine weitere Komponente
                erstellt, das Dashboard. Auf dem Dashboard werden "Top Heroes"
                angezeigt. Genau wie in der HeroesComponent sollen hier die
                Details der Heroes angezeigt werden, wenn der/die Nutzer:in auf
                einen "Top Hero" klickt.
              </li>
              <li>
                <p class="exkurs">Routing</p>
                Das Routing in Angular hilft uns, von einer Ansicht zur anderen
                zu navigieren, während Benutzer:innen Aufgaben in Web-Apps
                ausführen. Der Angular-Router ist ein Kernstück der
                Angular-Plattform. Angular bietet eine vollständige
                Routing-Bibliothek mit der Möglichkeit, mehrere Router-Ausgänge,
                verschiedene Pfadanpassungsstrategien, einfachen Zugriff auf
                Routenparameter und route guards (Routenwächter) zum Schutz vor
                unbefugtem Zugriff auf Komponenten.
                <br />
                Ein Router funktioniert wie folgt:
                <ul>
                  <li>
                    er liest die Browser-URL, zu der der/die Benutzer:in
                    navigieren möchte
                  </li>
                  <li>
                    er wendet eine URL-Umleitung an (sofern eine definiert ist)
                  </li>
                  <li>
                    er findet heraus, welcher Router-Zustand der URL entspricht
                  </li>
                  <li>
                    er führt die Guards aus, die im Routerstatus definiert sind
                  </li>
                  <li>
                    er löst die erforderlichen Daten für den Routerstatus auf
                  </li>
                </ul>
              </li>
              <li>
                Im Tutorial wird ein neues Routing-Module erstellt, um im
                späteren Verlauf zwischen dem Dashboard (kommt noch) und der
                Heroes Seite zu wechseln. Das Module wird app-routing.module.ts
                genannt. Es gibt zwei typische Elemente:<br />
                <br />
                path: eine Zeichenfolge, die mit der URL in der Adressleiste des
                Browsers übereinstimmt.
                <br /><br />
                component: die Komponente, die der Router erstellen soll, wenn
                er zu dieser Route navigiert.<br />
                <pre><code>  
    const routes: Routes = [
      { path: 'heroes', component: HeroesComponent }
    ];
    </code
                  ></pre>
                In der app.component.html wird die &lt;app-heroes&gt; durch
                &lt;router-outlet&gt; ausgetauscht. Zusätzlich wird ein
                routerLink hinzugefügt.
                <pre>
                  <code>
    &lt;a routerLink="/dashboard"&gt;Dashboard&lt;/a&gt;
    &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt;
                  </code>
                </pre>
              </li>

              <li>
                Damit die verschiedenen Komponenten untereinander verknüpft
                sidn, werden mehrere routerLinks gesetzt. Dieser verknüpft auch
                die Detailansicht sowohl mit dem Dashboard als auch mit der
                HeroesComponent.
              </li>
            </ul>
            <!---<p class="exkurs">Kapitel 6</p>
            Im sechsten und letzten Kapitel geht es darum Daten von einem Server
            abzurufen. Der/die Nutzer:in soll zudem die Möglichkeit haben Helden
            anzulegen, zu löschen und zu bearbeiten. Diese Änderungen sollen
            dann über HTTP gespeichert werden:
            <div class="video_container_iframe">
              <iframe
                class="stackBlitz"
                loading="lazy"
                src="https://stackblitz.com/edit/angular-ivy-quvz9h?embed=1&file=src/app/hero.service.ts"
              ></iframe>
            </div>
            <ul>
              <li>
                Der/Die Nutzer:in kann dann wie folgt in der Anwendung
                navigieren:
                <img
                  src="/Web_Themen_Technologien/assets/nav-diagram.png"
                  alt="Navigationsschaubild Tour of Heroes"
                />
              </li>
              <li>
                Wie auf der Grafik zu sehen wurde eine weitere Komponente
                erstellt, das Dashboard. Auf dem Dashboard werden "Top Heroes"
                angezeigt. Genau wie in der HeroesComponent sollen hier die
                Details der Heroes angezeigt werden, wenn der/die Nutzer:in auf
                einen "Top Hero" klickt.
              </li>
              <li>
                <p class="exkurs">Routing</p>
                Das Routing in Angular hilft uns, von einer Ansicht zur anderen
                zu navigieren, während Benutzer:innen Aufgaben in Web-Apps
                ausführen. Der Angular-Router ist ein Kernstück der
                Angular-Plattform. Angular bietet eine vollständige
                Routing-Bibliothek mit der Möglichkeit, mehrere Router-Ausgänge,
                verschiedene Pfadanpassungsstrategien, einfachen Zugriff auf
                Routenparameter und route guards (Routenwächter) zum Schutz vor
                unbefugtem Zugriff auf Komponenten.
                <br />
                Ein Router funktioniert wie folgt:
                <ul>
                  <li>
                    er liest die Browser-URL, zu der der/die Benutzer:in
                    navigieren möchte
                  </li>
                  <li>
                    er wendet eine URL-Umleitung an (sofern eine definiert ist)
                  </li>
                  <li>
                    er findet heraus, welcher Router-Zustand der URL entspricht
                  </li>
                  <li>
                    er führt die Guards aus, die im Routerstatus definiert sind
                  </li>
                  <li>
                    er löst die erforderlichen Daten für den Routerstatus auf
                  </li>
                </ul>
              </li>
              <li>
                Im Tutorial wird ein neues Routing-Module erstellt, um im
                späteren Verlauf zwischen dem Dashboard (kommt noch) und der
                Heroes Seite zu wechseln. Das Module wird app-routing.module.ts
                genannt. Es gibt zwei typische Elemente:<br />
                <br />
                path: eine Zeichenfolge, die mit der URL in der Adressleiste des
                Browsers übereinstimmt.
                <br /><br />
                component: die Komponente, die der Router erstellen soll, wenn
                er zu dieser Route navigiert.<br />
                <pre><code>  
    const routes: Routes = [
      { path: 'heroes', component: HeroesComponent }
    ];
    </code
                  ></pre>
                In der app.component.html wird die &lt;app-heroes&gt; durch
                &lt;router-outlet&gt; ausgetauscht. Zusätzlich wird ein
                routerLink hinzugefügt.
                <pre>
                  <code>
    &lt;a routerLink="/dashboard"&gt;Dashboard&lt;/a&gt;
    &lt;a routerLink="/heroes"&gt;Heroes&lt;/a&gt;
                  </code>
                </pre>
              </li>

              <li>
                Damit die verschiedenen Komponenten untereinander verknüpft
                sidn, werden mehrere routerLinks gesetzt. Dieser verknüpft auch
                die Detailansicht sowohl mit dem Dashboard als auch mit der
                HeroesComponent.
              </li>
            </ul>
          </dd>-->
          </dd>
        </dl>
      </div>
      <a class="button" href="javascript:history.back()">Zurück</a>
    </div>
    <!------------Footer-------------->
    <footer class="footer">
      <div>
        <dl>
          <dt class="footer-schrift">Quellen</dt>
          <dd>
            <a
              target="_blank"
              href="https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/"
              >Unterschied von Framework und Library</a
            >
          </dd>
          <dd>
            <a
              target="_blank"
              href="https://kinsta.com/de/blog/javascript-bibliotheken/#was-sind-javascript-bibliotheken"
              >Liste an Frameworks</a
            >
          </dd>
          <dd>
            <a target="_blank" href="https://angular.io/tutorial"
              >Angular Tour of Heroes - Tutorial</a
            >
          </dd>
        </dl>
      </div>
    </footer>
  </body>
</html>
